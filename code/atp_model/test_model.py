import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import re
from pathlib import Path
import statsmodels.formula.api as smf
from sklearn.model_selection import train_test_split
import shutil
from sklearn.metrics import accuracy_score, roc_auc_score, log_loss, brier_score_loss


INPUT_DIR = "logit_csv"
OUTPUT_DIR = "logit_test"

FP_PATTERN = re.compile(rf"{INPUT_DIR}/(?P<year>\d{{4}})/logit_(?P<tier>[\w_]+).csv")

TEST_YEARS = [2022, 2023, 2024]


def refresh_output():
    p = Path(OUTPUT_DIR)
    if p.exists():
        shutil.rmtree(p)
    p.mkdir(parents=True, exist_ok=True)
    return p


def read_data():
    """
    Reads in the csvs and stores them in dictionaries matching the directory
    structure. Returns the dictionary as well as a list of the tiers for
    convenient itteration.
    """
    data = dict()
    data_path = Path(INPUT_DIR)
    if not data_path.exists():
        print(
            "You need to run ht_logit_csv.py first, this script depends on the data generated by it."
        )
        return 1

    tiers = set()
    for fn in data_path.rglob("*.csv"):
        fn_match = re.search(FP_PATTERN, str(fn))
        if fn_match:
            print(f"Processing: {fn}…")
            year = int(fn_match.group("year"))
            tier = fn_match.group("tier")
            tiers.add(tier)
            if year not in data:
                data[year] = dict()
            df = pd.read_csv(fn)
            data[year][tier] = df
        else:
            print(f"Skipping: {fn}…")
    # Small sanity check.
    assert len(tiers) == 3
    return data, list(tiers)


def process_data(data):
    """
    Adds the years and tiers to the dataframes. They were omitted before for
    readability.
    """
    for year in data.keys():
        # Some tiers are missing from earlier years, this way there is no need
        # for checks.
        for tier in data[year].keys():
            data[year][tier]["year"] = year
            data[year][tier]["tier"] = tier


def get_training_data(data, tiers):
    """
    Combines the data into a dictionary of the training sets. Done this way
    because a specific year is the test set, but alternatively
    from sklearn.model_selection import train_test_split
    could be used.
    """
    combined_data = dict()
    combined_data["all"] = []
    for tier in tiers:
        combined_data[tier] = []
    for year in data.keys():
        if year in TEST_YEARS:
            continue
        # Some tiers are missing from earlier years, this way there is no need
        # for checks.
        for tier in data[year].keys():
            combined_data[tier].append(data[year][tier])
            combined_data["all"].append(data[year][tier])
    training_data = dict()
    for tier in combined_data.keys():
        training_data[tier] = pd.concat(combined_data[tier], ignore_index=True)
    return training_data


def get_testing_data(data):
    """
    Same as get_training_data but for the testing data.
    """
    testing_data = dict()
    all = []
    for test_year in TEST_YEARS:
        for tier in data[test_year].keys():
            testing_data[tier] = data[2024][tier]
            all.append(data[2024][tier])
    testing_data["all"] = pd.concat(all, ignore_index=True)
    return testing_data


def get_bounds(training_data, testing_data):
    min_ht = min(
        training_data["all"][["player_ht", "opponent_ht"]].min().min(),
        testing_data["all"][["player_ht", "opponent_ht"]].min().min(),
    )
    max_ht = max(
        training_data["all"][["player_ht", "opponent_ht"]].max().max(),
        testing_data["all"][["player_ht", "opponent_ht"]].max().max(),
    )
    return min_ht, max_ht


def main():
    refresh_output()
    data, tiers = read_data()
    process_data(data)
    training_data = get_training_data(data, tiers)
    testing_data = get_testing_data(data)
    min_ht, max_ht = get_bounds(training_data, testing_data)
    formulas = []
    formulas.append(
        f"win ~ "
        f"bs(player_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht}) + "
        f"bs(opponent_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
    )
    formulas.append(f"win ~ " f"bs(player_ht - opponent_ht, df=5)")
    formulas.append("win ~ player_ht - opponent_ht")  # plain linear diff
    formulas.append("win ~ I(player_ht - opponent_ht) + I(player_ht + opponent_ht)")
    formulas.append("win ~ I(player_ht - opponent_ht) + I((player_ht + opponent_ht)/2)")
    formulas.append("win ~ bs(player_ht - opponent_ht, df=5)")
    formulas.append("win ~ bs((player_ht + opponent_ht)/2, df=5)")
    formulas.append(
        "win ~ bs(player_ht - opponent_ht, df=5) + bs((player_ht + opponent_ht)/2, df=5)"
    )
    formulas.append(
        f"win ~ bs(player_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
        f" + bs(opponent_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
        f" + I(player_ht - opponent_ht)"
    )

    formulas.append(
        f"win ~ bs(player_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
        f" * bs(opponent_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
    )  # includes main effects + interaction

    formulas.append(
        f"win ~ bs(player_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
        f" + bs(opponent_ht, df=5, lower_bound={min_ht}, upper_bound={max_ht})"
        f" + bs(player_ht - opponent_ht, df=5)"
    )

    rows = []
    for formula in formulas:
        for tier in training_data.keys():
            train_df = training_data[tier]
            test_df = testing_data[tier]
            model = smf.logit(formula, data=train_df).fit()

            # How probable is our test data according to the model?
            p_test = model.predict(test_df)
            print(model.summary())
            print(model.pvalues.iloc[1])
            print(model.pvalues.iloc[2])

            # break
            y_test = test_df["win"].astype(int).values
            y_hat = (p_test >= 0.5).astype(int)

            accuracy = accuracy_score(y_test, y_hat)
            # accuracy = round(accuracy * 100, 2)
            row = {"formula": formula, "tier": tier, "accuracy": accuracy}
            rows.append(row)
        break

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
