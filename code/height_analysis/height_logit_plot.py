import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import re
from pathlib import Path
import statsmodels.formula.api as smf
from sklearn.model_selection import train_test_split
import shutil
from sklearn.metrics import accuracy_score, roc_auc_score, log_loss, brier_score_loss


INPUT_DIR = "logit_csv"
OUTPUT_DIR = "height_heatmaps"

FP_PATTERN = re.compile(
    rf"{INPUT_DIR}/(?P<year>\d{{4}})/logit_(?P<match_type>[\w_]+).csv"
)


def refresh_output():
    p = Path(OUTPUT_DIR)
    if p.exists():
        shutil.rmtree(p)
    p.mkdir(parents=True, exist_ok=True)
    return p


def main():
    data_path = Path(INPUT_DIR)
    if not data_path.exists():
        print(
            "You need to run clean_height_data.py first, this script depends on the data generated by it."
        )
        return 1

    refresh_output()

    data = dict()
    from_year = 2020

    for fn in data_path.rglob("*.csv"):
        fn_match = re.search(FP_PATTERN, str(fn))
        if fn_match:
            year = int(fn_match.group("year"))
            if year < from_year:
                continue
            print(f"Processing: {fn}â€¦")
            match_type = fn_match.group("match_type")
            if match_type not in data:
                data[match_type] = []

            df = pd.read_csv(fn)  # pyright: ignore

            data[match_type].append(df)
    for k in data.keys():
        # Merges the years for that match_type.
        df = pd.concat([frame for frame in data[k]], ignore_index=True)

        # print(len(df))
        df = df.dropna(subset=["player_ht", "opponent_ht", "win"])
        # print(len(df))

        # Behoorlijke todo om dit te begrijpen.
        model = smf.logit(
            "win ~ bs(player_ht, df=5) + bs(opponent_ht, df=5)", data=df
        ).fit()
        # print(model.summary())
        # TODO
        min_p, max_p = df["player_ht"].min(), df["player_ht"].max()
        min_o, max_o = df["opponent_ht"].min(), df["opponent_ht"].max()

        grid_p = np.linspace(min_p, max_p, 150)
        grid_o = np.linspace(min_o, max_o, 150)

        P, O = np.meshgrid(grid_p, grid_o)
        pred_df = pd.DataFrame({"player_ht": P.ravel(), "opponent_ht": O.ravel()})

        Z = model.predict(pred_df).values.reshape(P.shape)

        plt.figure(figsize=(6.5, 5.5))
        plt.imshow(
            Z,
            origin="lower",
            extent=[min_p, max_p, min_o, max_o],
            aspect="auto",
        )
        plt.xlabel("Player height")
        plt.ylabel("Opponent heigt")
        plt.title(f"Predicted win probability (20-24 {k})\nSpline on absolute heights")
        plt.colorbar(label="Win probability")
        plt.tight_layout()
        plt.savefig(f"{OUTPUT_DIR }/{k}.png")

        # Test

        print("Reached here!")
        # Split (stratify keeps win/loss balance similar)
        train_df, test_df = train_test_split(
            df, test_size=0.2, random_state=42, stratify=df["win"]
        )
        gmin_p, gmax_p = df["player_ht"].min(), df["player_ht"].max()
        gmin_o, gmax_o = df["opponent_ht"].min(), df["opponent_ht"].max()

        # Patsy formula
        # https://patsy.readthedocs.io/en/latest/spline-regression.html
        formula = (
            "win ~ "
            "bs(player_ht, df=5, lower_bound=gmin_p, upper_bound=gmax_p) + "
            "bs(opponent_ht, df=5, lower_bound=gmin_o, upper_bound=gmax_o)"
        )
        model = smf.logit(formula, data=train_df).fit(disp=0)

        # Probabilities on test set
        p_test = model.predict(test_df)

        # Threshold-based accuracy (0.5 is default, but not always optimal)
        y_test = test_df["win"].astype(int).values
        y_hat = (p_test >= 0.5).astype(int)

        print(f"{k}:")
        print("\tAccuracy:", accuracy_score(y_test, y_hat))
        print("\tROC AUC:", roc_auc_score(y_test, p_test))
        print("\tLog loss:", log_loss(y_test, p_test))
        print("\tBrier:", brier_score_loss(y_test, p_test))

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
