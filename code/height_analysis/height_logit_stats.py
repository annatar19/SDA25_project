import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import re
from pathlib import Path
import statsmodels.formula.api as smf
from sklearn.model_selection import train_test_split
import shutil
from sklearn.metrics import accuracy_score, roc_auc_score, log_loss, brier_score_loss


INPUT_DIR = "logit_csv"
OUTPUT_DIR = "height_heatmaps"

FP_PATTERN = re.compile(
    rf"{INPUT_DIR}/(?P<year>\d{{4}})/logit_(?P<match_type>[\w_]+).csv"
)


def refresh_output():
    p = Path(OUTPUT_DIR)
    if p.exists():
        shutil.rmtree(p)
    p.mkdir(parents=True, exist_ok=True)
    return p


def main():
    data_path = Path(INPUT_DIR)
    if not data_path.exists():
        print(
            "You need to run clean_height_data.py first, this script depends on the data generated by it."
        )
        return 1

    refresh_output()

    data = dict()
    from_year = 1900

    for fn in data_path.rglob("*.csv"):
        fn_match = re.search(FP_PATTERN, str(fn))
        if fn_match:
            year = int(fn_match.group("year"))
            if year < from_year:
                continue
            print(f"Processing: {fn}â€¦")
            match_type = fn_match.group("match_type")
            if match_type not in data:
                data[match_type] = []

            df = pd.read_csv(fn)  # pyright: ignore

            data[match_type].append(df)
    for k in data.keys():
        # Merges the years for that match_type.
        df = pd.concat([frame for frame in data[k]], ignore_index=True)
        df["dh"] = df["player_ht"] - df["opponent_ht"]
        df["h_mean"] = (df["player_ht"] + df["opponent_ht"]) / 2

        # Split the data into a training and a test set. stratify makes it so
        # we would never get only wins in the testset for instance.
        train_df, test_df = train_test_split(
            df, test_size=0.2, random_state=0, stratify=df["win"]
        )

        # Otherwise the model will get upset should it find values in the test
        # set that are greater or smaller than any in the training set.
        # ht_min, ht_max = df["player_ht"].min(), df["player_ht"].max()
        dh_min, dh_max = df["dh"].min(), df["dh"].max()

        h_mean_min, h_mean_max = df["h_mean"].min(), df["h_mean"].max()

        # Patsy formula, based on R? There is TODO
        # https://patsy.readthedocs.io/en/latest/spline-regression.html
        # formula = (
        #     f"win ~ "
        #     f"bs(player_ht, df=5, lower_bound={ht_min}, upper_bound={ht_max}) + "
        #     f"bs(opponent_ht, df=5, lower_bound={ht_min}, upper_bound={ht_max})"
        # )
        formula = f"win ~ bs(dh, df=5, lower_bound={dh_min}, upper_bound={dh_max}) +bs(h_mean, df=5, lower_bound={h_mean_min}, upper_bound={h_mean_max})"

        model = smf.logit(formula, data=train_df).fit()

        # How probable is our test data according to the model?
        p_test = model.predict(test_df)
        # print(test.max())

        # # Threshold-based accuracy (0.5 is default, but not always optimal)
        y_test = test_df["win"].astype(int).values
        y_hat = (p_test >= 0.5).astype(int)

        print(f"{k}, which has {len(df)/2} results:")
        # print(model.summary())
        print("\tAccuracy:", accuracy_score(y_test, y_hat))

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
