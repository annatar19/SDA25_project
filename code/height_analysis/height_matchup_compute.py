from pathlib import Path
import re
import numpy as np
import pandas as pd
import shutil


INPUT_DIR = "filtered_heights_classes"
OUTPUT_DIR = "matchups"


def get_row(df, match):
    year = int(match.group("year"))
    match_type = match.group("match_type")
    mean_ht = df["ht"].mean()
    # Sample std by default, so ddof=1
    std_ht = df["ht"].std()
    return {"year": year, "match_type": match_type, "mean": mean_ht, "std": std_ht}


# To clear the output folder.
def clear_output():
    p = Path(OUTPUT_DIR)
    if p.exists():
        shutil.rmtree(p)
    return p


def write_output(df):
    clear_output()
    path = f"{OUTPUT_DIR}/"
    p = Path(path)
    p.mkdir(parents=True, exist_ok=True)
    out_fn = f"{path}/height_stats.csv"
    wide = df.pivot(
        index="year", columns="match_type", values=["mean", "std"]
    ).sort_index()

    # Flatten columns so CSV has simple headers
    wide.columns = [f"{stat}_{mt}" for stat, mt in wide.columns]

    wide.to_csv(out_fn, index=True)


def main():
    data_path = Path(INPUT_DIR)
    if not data_path.exists():
        print(
            "You need to run height_matchup_classify.py first, this script depends on the data generated by it."
        )
        return 1

    # Should not be needed for filtering, but serves as a small sanity check.
    # It is also conventient to extract the fields from the name.
    p_pattern = re.compile(
        r"filtered_heights_classes/(?P<year>\d{4})/ht_class_(?P<match_type>[\w_]+).csv"
    )
    # To store the output rows.
    rows = []
    # Will list every .csv in filtered_heights.
    for p in data_path.rglob("*.csv"):
        match = re.search(p_pattern, str(p))
        # Should always be true unless filtered_heights was manually altered,
        # but this is cleaner.
        if match:
            print(p)
            df = pd.read_csv(p)
            classes = [0, 1, 2]

            wins = (
                df.groupby(["winner_ht_class", "loser_ht_class"])
                .size()
                .unstack(fill_value=0)
                .reindex(index=classes, columns=classes, fill_value=0)
            )

            # Pairwise probability matrix
            denom = wins + wins.T
            prob = wins / denom.replace(0, np.nan)

            # Diagonal is not meaningful for "beats another class"
            np.fill_diagonal(prob.values, np.nan)  # or 0.5 if you prefer

            print("Wins:\n", wins)
            print("\nP(i beats j):\n", prob)
            break

            # df = combine_winners_losers(df)
            # rows.append(get_row(df, match))

    # out = pd.DataFrame(rows)
    # write_output(out)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
