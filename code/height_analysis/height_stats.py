from pathlib import Path
import numpy as np
import re
import pandas as pd
import shutil
from scipy import stats


INPUT_DIR = "filtered_heights/"
OUTPUT_DIR = "height_stats/"


def combine_winners_losers(df):
    """
    This converts a dataframe with columns:
    winner_id, winner_name, winner_ht, loser_id, loser_name, loser_ht
    to a dataframe with columns:
    id, name, ht
    By renaming the columns and pasting the loser data below the winner data
    """
    winners = df[["winner_id", "winner_name", "winner_ht"]].rename(
        columns={
            "winner_id": "id",
            "winner_name": "name",
            "winner_ht": "ht",
        }
    )

    losers = df[["loser_id", "loser_name", "loser_ht"]].rename(
        columns={
            "loser_id": "id",
            "loser_name": "name",
            "loser_ht": "ht",
        }
    )

    # Simply pastes the rows together. The ignore_index makes it so that the
    # index of the loser portion of data does not start at 0, it starts at
    # len(winners).
    return pd.concat([winners, losers], ignore_index=True)


def get_row(df, match):
    year = int(match.group("year"))
    match_type = match.group("match_type")
    # One height per id, so that a player playing in 3 matches does not get
    # interpreted as 3 players with the same height.
    players = df.drop_duplicates(subset="id")
    mean_ht = players["ht"].mean()
    std_ht = players["ht"].std(ddof=1)
    n = players.shape[0]
    # https://en.wikipedia.org/wiki/Confidence_interval#Methods_of_derivation
    standard_error = std_ht / np.sqrt(n)
    alpha = 0.05
    t_critical = stats.t.ppf(1 - alpha / 2, df=n - 1)
    ci_lower = mean_ht - t_critical * standard_error
    ci_upper = mean_ht + t_critical * standard_error

    return {
        "year": year,
        "match_type": match_type,
        "mean": mean_ht,
        "ci_lower": ci_lower,
        "ci_upper": ci_upper,
        "std": std_ht,
    }


# To clear the output folder.
def clear_output():
    p = Path(OUTPUT_DIR)
    if p.exists():
        shutil.rmtree(p)
    return p


def write_output(df, type_str):
    path = f"{OUTPUT_DIR}/"
    p = Path(path)
    p.mkdir(parents=True, exist_ok=True)
    out_fn = f"{path}/height_{type_str}_stats.csv"
    wide = df.set_index("year")[["mean", "ci_lower", "ci_upper", "std"]].sort_index()

    # wide.columns = [f"{stat}_{mt}" for stat, mt in wide.columns]

    wide.to_csv(out_fn, index=True)


def main():
    data_path = Path(INPUT_DIR)
    if not data_path.exists():
        print(
            "You need to run clean_height_data.py first, this script depends on the data generated by it."
        )
        return 1

    clear_output()
    # Should not be needed for filtering, but serves as a small sanity check.
    # It is also conventient to extract the fields from the name.
    p_pattern = re.compile(
        r"filtered_heights/(?P<year>\d{4})/ht_(?P<match_type>[\w_]+).csv"
    )
    # To store the output rows.
    future_rows = []
    quall_rows = []
    singles_rows = []
    # Will list every .csv in filtered_heights.
    for p in data_path.rglob("*.csv"):
        match = re.search(p_pattern, str(p))
        # Should always be true unless filtered_heights was manually altered,
        # but this is cleaner.
        if match:
            print(f"Processing: {p}â€¦")
            df = pd.read_csv(p)
            df = combine_winners_losers(df)
            row = get_row(df, match)
            if row["match_type"] == "futures":
                future_rows.append(row)
            elif row["match_type"] == "qual_chall":
                quall_rows.append(row)
            elif row["match_type"] == "singles":
                singles_rows.append(row)
            else:
                print(f"Unknown match type: {row["match_type"]}")
                return 1

    future_df = pd.DataFrame(future_rows)
    quall_df = pd.DataFrame(quall_rows)
    singles_df = pd.DataFrame(singles_rows)
    write_output(future_df, "futures")
    write_output(quall_df, "quall")
    write_output(singles_df, "singles")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
