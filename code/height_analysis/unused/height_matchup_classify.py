from pathlib import Path
import re
import pandas as pd
import shutil


INPUT_DIR = "filtered_heights"
OUTPUT_DIR = "filtered_heights_classes"


def combine_winners_losers(df):
    """
    This converts a dataframe with columns:
    winner_id, winner_name, winner_ht, loser_id, loser_name, loser_ht
    to a dataframe with columns:
    id, name, ht
    By renaming the columns and pasting the loser data below the winner data
    """
    winners = df[["winner_id", "winner_name", "winner_ht"]].rename(
        columns={
            "winner_id": "id",
            "winner_name": "name",
            "winner_ht": "ht",
        }
    )

    losers = df[["loser_id", "loser_name", "loser_ht"]].rename(
        columns={
            "loser_id": "id",
            "loser_name": "name",
            "loser_ht": "ht",
        }
    )

    # Simply pastes the rows together. The ignore_index makes it so that the
    # index of the loser portion of data does not start at 0, it starts at
    # len(winners).
    return pd.concat([winners, losers], ignore_index=True)


# To clear the output folder.
def clear_output():
    p = Path(OUTPUT_DIR)
    if p.exists():
        shutil.rmtree(p)
    return p


def write_output(df, year, match_type):
    path = f"{OUTPUT_DIR}/{year}"
    p = Path(path)
    p.mkdir(parents=True, exist_ok=True)
    out_fn = f"{path}/ht_class_{match_type}.csv"
    df.to_csv(out_fn, index=False)


def main():
    data_path = Path(INPUT_DIR)
    if not data_path.exists():
        print(
            "You need to run clean_height_data.py first, this script depends on the data generated by it."
        )
        return 1

    # Should not be needed for filtering, but serves as a small sanity check.
    # It is also conventient to extract the fields from the name.
    p_pattern = re.compile(
        r"filtered_heights/(?P<year>\d{4})/ht_(?P<match_type>[\w_]+).csv"
    )

    # Refresh the output dir.
    clear_output()

    # Will list every .csv in filtered_heights.
    for p in data_path.rglob("*.csv"):
        match = re.search(p_pattern, str(p))
        # Should always be true unless filtered_heights was manually altered,
        # but this is cleaner.
        if match:
            print(p)
            df = pd.read_csv(p)
            players = combine_winners_losers(df)
            players = players.drop_duplicates(subset="id", keep="first").reset_index(
                drop=True
            )
            players["ht_class"] = pd.qcut(
                players["ht"], q=3, labels=[0, 1, 2], duplicates="drop"
            )
            ht_class_map = players.set_index("id")["ht_class"]
            df["winner_ht_class"] = df["winner_id"].map(ht_class_map).astype(int)
            df["loser_ht_class"] = df["loser_id"].map(ht_class_map).astype(int)
            out = df[
                [
                    "winner_id",
                    "winner_name",
                    "winner_ht_class",
                    "loser_id",
                    "loser_name",
                    "loser_ht_class",
                ]
            ]
            year = match.group("year")
            match_type = match.group("match_type")
            write_output(out, year, match_type)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
